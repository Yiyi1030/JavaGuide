# Redis

-[redis为什么快](#redis为什么快)

-[redis的MGET和SCAN区别](#redis的MGET和SCAN区别)

-[redis是单线程的，如何保证顺序](#redis是单线程的，那执行任务也是单线程执行的吗，如何保证顺序)

-[redis数据类型](#redis数据类型有哪些)

-[redis的使用场景](#redis你用过哪些场景)

-[Redisson](#Redisson接触过吗)

-[redis的过期策略](#redis同时采用了两种过期策略)

-[redis的内存淘汰策略](#redis内存淘汰策略)

-[redis的持久化方式](#redis的持久化方式)

-[缓存击穿、缓存雪崩、缓存穿透](#缓存击穿、缓存雪崩、缓存穿透)

-[分布式场景问题](#分布式场景问题)

  -[redis主从集群、哨兵模式](#redis主从集群、哨兵模式)

  -[主从数据同步](#主节点将数据变更同步到所有的从节点，具体是怎么做的呢？)

  -[缓存和数据一致性](#缓存和数据一致性保障)

## redis为什么快

| redis为什么快                            | 描述                                                         |
| ---------------------------------------- | ------------------------------------------------------------ |
| 单线程模型                               | 处理客户端的请求，避免了多线程之间的上下文切换，同时简化了代码的复杂度。 |
| 数据结构简单                             | 数据结构简单，操作高效，提供的数据类型如字符串、             |
| 完全基于内存                             | 数据保存在内存，内存读写速度远高于硬盘，所以读写效率很高  引申的问题：  1、内存存储价格昂贵，所以不适合存储海量数据  2、redis有没有持久化落磁盘机制呢：是有的，rdb和aof |
| 支持批量操作                             | 提供了pipeline机制，优化网络传输，批量操作一次执行多个命令可以减少网络通信次数  pipeline机制有缺点吗：  1、多个命令间不具有原子性，可能部分成功（有办法解决吗，可以用redis的事务机制）  2、单次pipeline大量命令可能会占用大量服务器内存 |
| 非阻塞I/O和事件驱动模型  多路I/O复用模型 | 使用了非阻塞I/O和事件驱动模型，能够高效地处理大量并发连接  主要是并行处理I/O类操作，网络交互、磁盘交互等，不涉及数据类操作 |

 

I/O多路复用技术可以让服务器在单个线程中同时处理多个客户端的连接请求。

它的基本原理是，服务器有多个I/O操作需要等待，使用I/O多路复用技术可以在一个线程中等待多个I/O操作，只要有一个I/O操作就绪，就可以进行处理，这样就可以在单个线程中处理多个连接请求。

I/O多路复用技术主要有select、poll、epoll等几种实现方式，它们的主要区别在于效率和可处理的连接数。

其中，epoll的效率最高，可处理的连接数最多，是Linux下高并发服务器编程的主流选择。

epoll相比于select和poll，其优势在于当需要处理的文件描述符数量较大时，epoll的效率更高，因为epoll_wait返回的是已经就绪的文件描述符，而不需要像select和poll那样遍历所有文件描述符。

poll相比select，没有FD数量限制

 

 

 

## redis的MGET和SCAN区别

总结来说，scan适合全量数据拉取或迭代，不适合指定查询

| 命令 | 解释                                                         |
| ---- | ------------------------------------------------------------ |
| MGET | 批量查询命令，一次查询多条数据                               |
| SCAN | 基于游标的迭代器思路组织查询  redis会返回一个新的游标和当前步骤迭代到的一些元素。这个新的游标会在下一次迭代中使用。  Scan命令内部使用的是哈希表的随机算法，每次从哈希表的某个位置开始，向后遍历一定数量的元素。由于Redis的哈希表可能会进行扩容或收缩，所以Scan命令可能会遍历到同一个元素多次，也可能会漏掉一些元素。但是，只要在整个迭代过程中，哈希表的大小没有改变，Scan命令就能保证每个元素都能被遍历到 |

 

 

## redis是单线程的，那执行任务也是单线程执行的吗，如何保证顺序

是单线程的，且单个操作是原子的，两个并发的操作不会同时执行，所以天然有序

但是注意，如上表格所说，这个单线程只是数据操作的单线程，redis在进行磁盘I/O操作、网络I/O操作时，会使用异步非阻塞I/O和多线程来处理，提高效率

 

 

 

 

## redis数据类型有哪些

| 类型                   | 解释                                                         |
| ---------------------- | ------------------------------------------------------------ |
| 字符串（String）：     | 最基本的类型，一个键最大能存储512MB。                        |
| 哈希（Hash）：         | 键值对的集合，是一个string类型的field和value的映射表，其值的最大长度和数量都是512MB。  底层结构：哈希表 |
| 列表（List）：         | 是简单的字符串列表，按插入顺序排序。可以添加一个元素到列表的头部（左边）或者尾部（右边）。  底层结构：ziplist（压缩列表）+ 双向链表，数据量较少时使用ziplist，数据量大时转为双向链表 |
| 集合（Set）：          | 是string类型的无序集合。集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。  底层结构：intset（整数集合）+ 哈希表，数据量较少时使用intset，数据量大时转为哈希表 |
| 有序集合（Sorted Set） | 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行排序。  底层结构：跳表（skipList） + 哈希表，通过跳表来实现score排序，通过哈希表来实现快速访问  哈希表存储，key为元素，value为分数  跳表存储元素及其对应的分数，并按照分数对元素进行排序 |

其余结构知道或理解就行了，跳表有些面试可能会抠点细节，所以可以重点了解下：https://blog.csdn.net/wuhuayangs/article/details/121908774

思路上总结来说，跳表就是多层链表，同一个节点在多层存在，优先从高层往后找，找不到就降层次，直到找到

另外跳表在插入数据时，层数是随机的，这样可以快速插入

 

跳表基于单向链表可以实现快速查找、插入和删除

多叉树也是一种可以进行快速查找、插入、删除操作的数据结构，为什么不像数据库那样使用多叉树呢？

1、跳表实现简单，相对节省空间

2、多叉树的性能没有跳表稳定，在一些插入下可能需要做平衡和调整树动作

 

反过来看，数据库为什么使用多叉树来实现索引存储？

1、索引是存储在磁盘上，多叉树的层级一般在4层以内，层级比跳表低，I/O操作会少

2、跳表的节点可能在物理存储上不连续，多叉树的多个节点一般会在一个数据页上，减少磁盘I/O操作



 

 

## redis你用过哪些场景

| 场景        | 描述                                                         | 原理                                                         |
| ----------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 位图        | 适合用来压缩存储数据，比如存储用户的登录状态  SETBIT  bitmap001 12345 1 | 类似于二进制数组存储0、1  将数组第12345位上置为1，1-代表用户12345已登录 |
| 布隆过滤器  | 布隆过滤器是一种空间效率极高的概率型数据结构，用于测试一个元素是否在一个集合中。  布隆过滤器的主要优点是空间效率和查询时间都远超一般的算法，但是它存在一定的误判率，并且元素一旦添加进去就不能删除。 | 布隆过滤器可以判断，不存在的一定不存在，存在的不一定存在  怎么理解呢？  可以简单理解为，一个二进制数组，通过hash函数把摸一个key映射到某一位上，存在置为0，不存在置为1，所以我们可以用来判断，数据是否已存在，但由于hash冲突，同一个key可能会映射到同一位上，所以无法判断是否真的存在。 |
| 分布式锁    | setnx命令，不存在则写入成功，存在则写入失败  setnx是原子性的，多个客户端同时操作，也只能成功一个  利用这个命令，可以在并发场景下加排他锁 | setnx直接实现                                                |
| HyperLogLog | 用于处理大数据统计的算法，主要用于解决大数据的基数统计问题。它可以在有限的内存空间下，对海量数据进行去重计数，虽然结果是一个估计值，但是误差可以控制在1%以内。 |                                                              |

 

 

## Redisson接触过吗

是开源的一个java操作redis的客户端，提供了丰富的Redis操作接口，还提供了许多分布式相关的操作服务

Redisson提供了两种分布式锁的实现：

1、RLock：最常见的锁，包含锁的基本操作，如lock，unlock，tryLock等方法。（lock、tryLock的区别？lock会阻塞当前线程，tryLock获取不到立即返回）

2、RFairLock：公平锁，通过队列来保证锁的获取会按照申请的顺序进行。

这两种锁都实现了java.util.concurrent.locks.Lock接口。

Redisson的分布式锁实现上会有默认过期时间30s，所以引入了看门狗机制，每隔30s自动续期

 

 

 

 

## redis的key过期算法，内存淘汰策略

### redis同时采用了两种过期策略

| 过期策略 | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 定时删除 | 当设置key的过期时间时，同时创建一个定时器，当到达过期时间时，立即删除该key。  这种方式可以保证过期key会被及时删除，如果大量key集中过期，可能会阻塞Redis的主线程，导致停止服务。 |
| 惰性删除 | 当某个客户端试图访问一个key时，Redis才会检查该key是否过期，如果过期则删除。  这种方式的优点是分摊了删除过期key的计算量，避免了大量key同时过期导致的阻塞问题。  缺点是如果过期的key没有被访问，那么这些key就会一直存在于内存中，占用内存空间。 |

  

### redis内存淘汰策略

| 内存淘汰策略                            | 解释                                                         |
| --------------------------------------- | ------------------------------------------------------------ |
| noeviction                              | 内存不足以容纳新写入数据时，新写入操作会报错，这是默认策略。 |
| lru  allkeys-lru  volatile-lru          | 最近最少使用，优先移除  当内存不足以容纳新写入数据时，在键空间中，移除最少使用的 key。  当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最少使用的 key。 |
| random  allkeys-random  volatile-random | 随机移除  当内存不足以容纳新写入数据时，在键空间中，随机移除某个 key。  当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个 key。 |
| volatile-ttl                            | 当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的 key 会优先移除。 |

经常引申的问题：如果你来实现一个LRU算法，怎么实现呢？

1、利用LinkedHashMap底层实现的双向链表和重写它的removeEldestEntry方法，可以简单实现（removeEldestEntry默认实现是false，不移除）

2、自己实现一个双向链表，每个被访问到的数据都移动到表尾，当达到链表上限时抛弃表头

 

 

 

## redis的持久化方式

| 类型     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| rdb      | 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是做一次全量备份。  这种方式适合大规模的数据恢复，且对性能影响小，但可能会丢失最后一次快照后的所有修改。 |
| aof      | 记录服务器接收到的所有写操作命令，并在服务器启动时，通过重新执行这些命令来还原数据。  AOF 文件的更新操作是追加模式，因此对于相同的数据集，AOF 文件的体积通常要大于 RDB 文件的体积。  Redis 可以：  在每次执行写入命令时就立即将命令写入 AOF 文件  也可以每秒写入一次  在每次有写入命令时将命令追加到 AOF 缓冲区，然后由后台线程负责将缓冲区的内容写入到 AOF 文件。 |
| 日常应用 | 两者可以同时启用，  当 Redis 重启时，如果 AOF 存在，那么 Redis 会优先使用 AOF 文件来恢复数据。  理论上来说，aof和rdb都可能会丢失数据，但是aof一般会比rdb完整，既然aof更完整，为什么不直接使用aof呢？  aof有其缺陷：  1、aof的文件体积更大  2、aof文件的恢复速度比rdb慢  3、如果配置不合理的情况下，aof写磁盘的效率会影响到redis写 |

 

 

 

## 缓存击穿、缓存雪崩、缓存穿透

| 类型     | 解释                                                         | 如何解决                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 缓存击穿 | 指一个存在的 key，在缓存过期的一刹那，恰好有大量的请求并发查询这个 key，导致所有的请求都落到数据库上，造成数据库短时间内压力过大。 | 设置热点数据永不过期                                         |
| 缓存雪崩 | 指在某一个时间段内，缓存中的大量数据同时过期，导致大量的请求都落到数据库上，造成数据库短时间内压力过大。 | 将缓存失效时间进行错峰（过期时间增加随机数）  使用熔断降级策略（数据库操作失败率到一定阈值后熔断） |
| 缓存穿透 | 指查询一个数据库中不存在的数据，由于缓存中也不会存在，所以每次查询都会落到数据库上，如果有恶意攻击，就会导致数据库压力过大。 | 将查询的结果（即使是空）也缓存起来  使用布隆过滤器，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免对底层存储系统的查询压力。 |

 

 

 

 

 

## 分布式场景问题

### redis主从集群、哨兵模式

| 类型          | 解释                                                         |
| ------------- | ------------------------------------------------------------ |
| redis主从集群 | redis的一种数据复制方式，主要包括一个主节点（master）和多个从节点（slave）。  主节点负责处理客户端的写操作，写操作完成后，主节点将数据变更同步到所有的从节点。  从节点负责处理客户端的读操作，可以提高系统的读取性能。同时，从节点也可以作为主节点的备份，当主节点出现故障时，可以快速切换到从节点，提高系统的可用性。  但Redis 主从集群不支持自动故障转移，主节点出现故障，需要手动将从节点提升为主节点。 |
| 哨兵模式      | redis 哨兵模式是一种高可用解决方案，主要用于监控和自动切换主从节点。  哨兵模式的主要功能包括：  监控：哨兵会定期检查主节点和从节点是否正常运行。  通知：当被监控的某个 Redis 节点出现故障时，哨兵可以通过 API 向管理员发送通知。  自动故障迁移：当主节点无法正常提供服务时，哨兵可以自动将一个从节点提升为新的主节点，并让其他从节点改变主节点为新的主节点。  配置提供者：客户端连接 Redis 时，可以先连接到哨兵，由哨兵告知客户端当前的主节点地址。 |

 

### 主节点将数据变更同步到所有的从节点，具体是怎么做的呢？

| 同步模式 | 描述                                                         |
| -------- | ------------------------------------------------------------ |
| 全量复制 | 当一个从节点刚连接到主节点时，主节点开始一个后台保存进程，将整个数据库写入到一个RDB文件中，  当RDB文件创建完毕后，主节点会将这个文件发送给从节点，从节点会保存到磁盘上，然后载入到内存中。  主节点同时还会将新接收到的所有写命令缓存起来，这个期间接收到的所有写命令发送给从节点进行执行。  就是利用的RDB的数据快照功能，做一个全量的同步 |
| 部分复制 | 如果主从节点之间的网络连接断开，当连接恢复后，如果断开的时间不是很长，主节点可能还保留有从节点断开后执行的所有写命令，  这时可以直接将这些写命令发送给从节点，从节点只需要执行这些写命令就可以将数据库更新至最新的状态。 |
|          | 两个同时使用，部分复制优先，部分复制无法满足诉求的话，优先使用全量复制 |

 

 

 

### 缓存和数据一致性保障

在使用了缓存+DB的情况，你们采用什么方式来保证数据的一致性呢？![image-20240407153706651](../image/数据库/redis/数据一致性.png)

1、延时双写异步回刷，所谓的异步回刷，是指对缓存的更新操作使用异步方式

写操作，删缓存 -》 写DB -》异步写缓存

读操作，查缓存 -》 查DB -》异步写缓存

2、binlog异步写缓存

写操作，删缓存 -》 写DB -》监听binlog异步写缓存（binlog是mysql的数据命令操作日志，天然具有顺序性）

读操作，查缓存 -》 查DB -》异步写缓存

3、引入MQ保证串行化

写操作，删缓存 -》 写DB -》监听binlog（binlog是mysql的数据命令操作日志，天然具有顺序性），串行写MQ -》异步写缓存

读操作，查缓存 -》 查DB -》串行写MQ -》异步写缓存

 

 